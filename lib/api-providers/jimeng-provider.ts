import { HairstyleProvider, HairstyleTaskParams, SubmitTaskResponse, TaskStatusResponse, ProviderConfig } from './types';
import { getVolcAuthHeader, buildHairstylePrompt, validatePrompt } from '../volcI2iUtils';

export class JimengProvider implements HairstyleProvider {
  readonly name = 'Jimeng3.0-VolcEngine';
  private accessKey: string;
  private secretKey: string;
  private baseUrl: string;
  private reqKey: string;
  private region: string;
  private service: string;

  constructor(config: ProviderConfig = {}) {
    this.accessKey = config.accessKey || process.env.VOLC_ACCESS_KEY || '';
    this.secretKey = config.secretKey || process.env.VOLC_SECRET_KEY || '';
    this.baseUrl = process.env.VOLC_I2I_API_URL || 'https://visual.volcengineapi.com';
    this.reqKey = process.env.VOLC_I2I_REQ_KEY || 'jimeng_i2i_v30';
    this.region = process.env.VOLC_I2I_REGION || 'cn-north-1';
    this.service = process.env.VOLC_I2I_SERVICE || 'cv';

    if (!this.accessKey || !this.secretKey) {
      throw new Error('Jimeng Provider requires VOLC_ACCESS_KEY and VOLC_SECRET_KEY environment variables');
    }
  }

  async submitTask(params: HairstyleTaskParams): Promise<SubmitTaskResponse> {
    const { imageUrl, hairStyle, hairColor } = params;
    
    try {
      console.log(`ğŸ¯ [Jimeng] Building prompt for hairStyle: "${hairStyle}", hairColor: "${hairColor}"`);
      const prompt = buildHairstylePrompt(hairStyle, hairColor);
      console.log(`ğŸ“ [Jimeng] Generated prompt: "${prompt}"`);
      validatePrompt(prompt);

      // Prepare image parameters (ä½¿ç”¨snake_caseæ ¼å¼ï¼Œå³æ¢¦APIçš„æ­£ç¡®å‚æ•°å)
      let imageParams: any = {};
      
      if (imageUrl.startsWith('http')) {
        // URLæ–¹å¼ - ä½¿ç”¨snake_caseæ ¼å¼
        imageParams = { image_urls: [imageUrl] };  // å³æ¢¦APIéœ€è¦snake_caseæ ¼å¼
        console.log(`[Jimeng] Using URL mode: ${imageUrl}`);
      } else {
        // Handle base64 data - å³æ¢¦APIéœ€è¦çº¯base64æ•°æ®ï¼Œä¸è¦data URLå‰ç¼€
        let base64Data: string;
        
        if (imageUrl.startsWith('data:')) {
          // å¦‚æœæ˜¯data URLæ ¼å¼ï¼Œæå–çº¯base64éƒ¨åˆ†
          const parts = imageUrl.split(',');
          if (parts.length === 2) {
            base64Data = parts[1]; // åªè¦base64æ•°æ®ï¼Œä¸è¦data:image/jpeg;base64,å‰ç¼€
          } else {
            throw new Error('Invalid data URL format');
          }
        } else {
          // å‡è®¾å·²ç»æ˜¯çº¯base64æ•°æ®
          base64Data = imageUrl;
        }
        
        // è°ƒè¯•ï¼šæ£€æŸ¥base64æ•°æ®æ ¼å¼
        console.log(`[Jimeng] Base64 data format check:`, {
          originalLength: imageUrl.length,
          processedLength: base64Data.length,
          originalPreview: imageUrl.substring(0, 50) + '...',
          processedPreview: base64Data.substring(0, 50) + '...',
          isValidBase64: /^[A-Za-z0-9+/]*={0,2}$/.test(base64Data.substring(0, 100))
        });
        
        // ä½¿ç”¨snake_caseæ ¼å¼çš„å‚æ•°åï¼Œå‘é€çº¯base64æ•°æ®ï¼ˆä¸è¦data URLå‰ç¼€ï¼‰
        imageParams = { binary_data_base64: [base64Data] };
      }

      const reqBody = {
        req_key: this.reqKey,
        prompt: prompt,  // æ”¹ä¸º prompt è€Œä¸æ˜¯ text
        seed: -1,        // æ·»åŠ éšæœºç§å­
        scale: 0.3,      // æ–‡æœ¬å½±å“åŠ› (èŒƒå›´0.3-0.5ï¼Œå¹³è¡¡promptæ§åˆ¶å’ŒåŸå›¾ä¿ç•™)
        width: 1024,     // ä¼˜åŒ–å°ºå¯¸ä»¥åŠ å¿«ç”Ÿæˆé€Ÿåº¦ (ä»1328é™ä½åˆ°1024)
        height: 1024,    // ä¼˜åŒ–å°ºå¯¸ä»¥åŠ å¿«ç”Ÿæˆé€Ÿåº¦
        ...imageParams
      };

      const path = '/?Action=CVSync2AsyncSubmitTask&Version=2022-08-31';
      const authHeaders = await getVolcAuthHeader('POST', path, reqBody);

      // æ·»åŠ å®Œæ•´çš„è¯·æ±‚ä½“æ—¥å¿—
      console.log(`[Jimeng] Full request body:`, JSON.stringify(reqBody, null, 2));
      console.log(`[Jimeng] Submitting task with params:`, {
        hairStyle: params.hairStyle,
        hairColor: params.hairColor,
        prompt: prompt,
        hasImageUrl: !!params.imageUrl,
        imageUrlPreview: params.imageUrl?.substring(0, 100) + '...',
        reqBodyKeys: Object.keys(reqBody)
      });

      const response = await fetch(`${this.baseUrl}${path}`, {
        method: 'POST',
        headers: {
          ...authHeaders
        },
        body: JSON.stringify(reqBody)
      });

      const responseData = await response.json() as any;
      
      console.log(`[Jimeng] Submit response:`, {
        status: response.status,
        ok: response.ok,
        requestId: responseData.ResponseMetadata?.RequestId || responseData.request_id,
        error: responseData.ResponseMetadata?.Error || responseData.message,
        code: responseData.code,
        result: responseData.Result
      });
      
      // æ‰“å°å®Œæ•´å“åº”å¸®åŠ©è¯Šæ–­
      console.log(`[Jimeng] Full response:`, JSON.stringify(responseData, null, 2));

      // Check for API-level errors
      if (responseData.code && responseData.code !== 0 && responseData.code !== 10000) {
        console.log(`[Jimeng] API returned error code ${responseData.code}: ${responseData.message}`);
        return {
          success: false,
          error: responseData.message || 'Image validation failed',
          error_code: responseData.code,
          error_detail: responseData.message
        };
      }

      // å³æ¢¦APIçš„TaskIdåœ¨data.task_idä¸­ï¼Œä¸æ˜¯Result.TaskId
      if (response.ok && responseData.data?.task_id) {
        return {
          success: true,
          taskId: responseData.data.task_id
        };
      }
      
      // Handle case where API returns success but no TaskId
      if (responseData.code === 10000 && !responseData.data?.task_id) {
        console.log(`[Jimeng] API returned success but no TaskId - image failed face detection`);
        return {
          success: false,
          error: 'Unable to detect a clear face in the photo. Please upload a high-quality front-facing portrait photo with good lighting and no obstructions (sunglasses, masks, etc.).',
          error_code: responseData.code,
          error_detail: 'Face detection failed. Requirements: Clear front-facing photo, face should be >20% of image, resolution >400x400px'
        };
      }
      
      return {
        success: false,
        error: responseData.ResponseMetadata?.Error?.Message || responseData.message || 'Jimeng API request failed',
        error_code: responseData.ResponseMetadata?.Error?.Code || responseData.code,
        error_detail: responseData.ResponseMetadata?.Error?.CodeN || responseData.ResponseMetadata?.Error?.Message || responseData.message
      };
    } catch (error) {
      console.error('[Jimeng] Submit error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error in Jimeng provider'
      };
    }
  }

  async getTaskStatus(taskId: string): Promise<TaskStatusResponse> {
    try {
      const reqBody = {
        req_key: this.reqKey,
        task_id: taskId,
        // Add req_json to request image URLs instead of base64
        req_json: JSON.stringify({
          return_url: true,
          logo_info: {
            add_logo: false,
            position: 0,
            language: 0,
            opacity: 1
          }
        })
      };

      const path = '/?Action=CVSync2AsyncGetResult&Version=2022-08-31';
      const authHeaders = await getVolcAuthHeader('POST', path, reqBody);

      const response = await fetch(`${this.baseUrl}${path}`, {
        method: 'POST',
        headers: {
          ...authHeaders
        },
        body: JSON.stringify(reqBody),
        signal: AbortSignal.timeout(5000)
      });

      if (!response.ok) {
        console.error(`[Jimeng] Status check failed: ${response.status}`);
        return {
          task_status: 'FAILED',
          success: false,
          error_code: response.status,
          error: `HTTP ${response.status}: ${response.statusText}`
        };
      }

      const statusData = await response.json();
      console.log(`[Jimeng] Status for task ${taskId}:`, statusData);
      
      // å³æ¢¦APIè¿”å›æ ¼å¼ï¼š{code: 10000, data: {binary_data_base64: [...], status: "..."}}
      if (statusData.code === 10000 && statusData.data) {
        const result = statusData.data;
        
        // Debug: Log the actual data structure
        console.log(`[Jimeng] Result data structure:`, {
          hasStatus: !!result.status,
          status: result.status,
          hasImageUrls: !!result.image_urls,
          imageUrlsLength: result.image_urls?.length,
          hasBinaryData: !!result.binary_data_base64,
          binaryDataLength: result.binary_data_base64?.length,
          firstImageUrl: result.image_urls?.[0],
          binaryDataPreview: result.binary_data_base64?.[0]?.substring(0, 50)
        });
        
        // æ ¹æ®æ˜ç¡®çš„statuså­—æ®µåˆ¤æ–­ä»»åŠ¡çŠ¶æ€
        if (result.status === 'success' || result.status === 'done') {
          // å¤„ç†ä¸åŒçš„å“åº”æ ¼å¼
          let imageData = null;
          
          // ä¼˜å…ˆä½¿ç”¨image_urlsï¼ˆHTTP URLsï¼‰
          if (result.image_urls && Array.isArray(result.image_urls) && result.image_urls.length > 0) {
            imageData = result.image_urls;
            console.log(`[Jimeng] Found image URLs:`, imageData);
          }
          // æ ¼å¼1ï¼šç›´æ¥åœ¨binary_data_base64ä¸­
          else if (result.binary_data_base64 && Array.isArray(result.binary_data_base64) && result.binary_data_base64.length > 0) {
            imageData = result.binary_data_base64;
            console.log(`[Jimeng] Found image data in binary_data_base64, length:`, imageData.length);
          }
          // æ ¼å¼2ï¼šåœ¨resp_dataä¸­è§£æ
          else if (result.resp_data) {
            try {
              const respData = typeof result.resp_data === 'string' ? JSON.parse(result.resp_data) : result.resp_data;
              console.log(`[Jimeng] Parsing resp_data:`, respData);
              
              // æ£€æŸ¥æ˜¯å¦æœ‰PreviewImageæˆ–å…¶ä»–å›¾ç‰‡å­—æ®µ
              const imageKeys = Object.keys(respData).filter(key => key.toLowerCase().includes('image') || key.toLowerCase().includes('preview'));
              if (imageKeys.length > 0) {
                const firstImageKey = imageKeys[0];
                const imageUris = respData[firstImageKey];
                
                if (Array.isArray(imageUris) && imageUris.length > 0) {
                  // å¦‚æœæ˜¯URIå¼•ç”¨ï¼Œéœ€è¦ä»åŸå§‹å“åº”ä¸­æŸ¥æ‰¾binary_data_base64
                  // æ£€æŸ¥åŸå§‹statusDataä¸­æ˜¯å¦æœ‰binary_data_base64
                  if (statusData.data && statusData.data.binary_data_base64 && Array.isArray(statusData.data.binary_data_base64)) {
                    imageData = statusData.data.binary_data_base64;
                  } else {
                    console.log(`[Jimeng] URI references found but no binary_data_base64:`, imageUris);
                  }
                }
              }
            } catch (e) {
              console.error(`[Jimeng] Failed to parse resp_data:`, e);
            }
          }
          
          if (imageData && Array.isArray(imageData) && imageData.length > 0) {
            // è½¬æ¢ä¸ºå‰ç«¯æœŸæœ›çš„æ ¼å¼: { data: { images: { "style": ["base64..."] } } }
            const returnData = {
              task_status: 2, // SUCCESS
              success: true,
              result: imageData, // ä¿æŒæ—§æ ¼å¼å…¼å®¹
              data: {
                images: {
                  "hairstyle": imageData // å‰ç«¯æœŸæœ›çš„æ ¼å¼
                }
              }
            };
            console.log(`[Jimeng] Returning success data:`, {
              hasData: !!returnData.data,
              hasImages: !!returnData.data?.images,
              imageKeys: Object.keys(returnData.data?.images || {}),
              firstImagePreview: returnData.data?.images?.hairstyle?.[0]?.substring(0, 50)
            });
            return returnData;
          } else {
            console.log(`[Jimeng] Task completed but no valid image data found`);
            return {
              task_status: 3, // FAILED
              success: false,
              error: 'Task completed but no image data was generated'
            };
          }
        } else if (result.status === 'failed' || result.status === 'error') {
          return {
            task_status: 3, // FAILED
            success: false,
            error: result.resp_data || 'Task failed'
          };
        } else {
          // in_queue, processing ç­‰çŠ¶æ€éƒ½è§†ä¸ºå¤„ç†ä¸­
          return {
            task_status: 1, // PROCESSING
            success: false,
            currentStatus: result.status // è¿”å›å…·ä½“çŠ¶æ€ä¾›è°ƒè¯•
          };
        }
      }
      
      // Fallback for different response format
      return {
        task_status: 'FAILED',
        success: false,
        error: 'Invalid response format from Jimeng API'
      };
    } catch (error) {
      console.error(`[Jimeng] Status error for task ${taskId}:`, error);
      return {
        task_status: 'FAILED',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error in status check'
      };
    }
  }
}